<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Headless Firefly-RK3399 Setup]]></title>
    <url>%2F2017%2F05%2F10%2Fheadless-firefly-rk3399-setup%2F</url>
    <content type="text"><![CDATA[li p { margin: 0; } .post-body .fancybox img { margin: 0 auto; } .post-body .fancybox img[alt="install-rk-usb-driver.png"] { margin: 0 auto; } Firefly-RK3399Flash ImageWindows: Download here, 或这里 Ubuntu 16.04 image: Firefly-RK3399_Ubuntu16.04_201703181519.img RK Tool: AndroidTool_Release_v2.38.rar RK USB driver: DriverAssitant_v4.5.rar Install RK USB Driver Run “DriverAssitant_v4.5/DriverInstall.exe” Connect device to host Connect the power adapter to board. Use Type-C cable to connect host and device together. Press and hold RECOVERY key. Shortly press RESET key. After around two seconds, release RECOVERY key. The host will prompt to have new device detected and configured. Open the Device Management, you’ll find a new device name “Rockusb Device”, as shown below. Return to previous step to reinstall driver if it is not shown. Flush image Run “AndroidTool_Release_v2.38/AndroidTool.exe” as Administrator. Edit “config.ini”, set “Selected=2” to English Switch to “Upgrade Firmware” tab page. Click “Firmware” button and open the image file. Detail information of the image file, like version and chip, is shown. Click “Upgrade” button to start flash. If upgrade fails, please try “LowerFormat” in the “Download Image” tab page first, then try again. WARN: If you flash firmware laoder different version of the original machine, please click “Erase Flash” before upgrading the firmware. Setup Firefly Connect Display or TV with HDMI cable Connect the power adapter to the board The board will boot automatically once power on Plug USB mouse &amp; keyboard to the board Now, you can control the board. Username: firefly Password: firefly Connect the Wi-Fi Enable SSH server Detect SSH server, ps aux | grep sshd Otherwise, sudo apt-get install openssh-server and sudo /etc/init.d/ssh start Get ip address, ifconfig | grep &quot;inet &quot; SSH from remote pc, ssh firefly@&lt;ip&gt; Screen Sharing from Firefly Install, sudo apt-get install vino Config, vino-preferences {% asset_img vino-preferences.png %} Start, /usr/lib/vino/vino-server --sm-disable Autostart, open “Session and Startup” and check “Desktop Sharing”, Remote access from Ubuntu Open “Remmina Remote Desktop Client” and add connection, Or, remote access from Mac, plz see here. Finally, you can control the board from remote PC, without extra accessories or devices. NOTE: You could get ip address of the board from your router’s home page.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Screen Sharing</tag>
        <tag>Ubuntu</tag>
        <tag>Firefly-RK3399</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Screen Sharing from Ubuntu to Mac]]></title>
    <url>%2F2017%2F05%2F09%2Fscreen-sharing-from-ubuntu-to-mac%2F</url>
    <content type="text"><![CDATA[.post-body .fancybox img { margin: 0 auto 25px; } Ubuntu1) Open “Desktop Sharing” and setup, 2) sudo apt-get install dconf-tools and run dconf-editor, Mac1) Spotlight Search “Screen Sharing” and connect to, 2) View and control “Ubuntu Desktop”, References Can no longer use Screen Share …]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Screen Sharing</tag>
        <tag>Remote Desktop</tag>
        <tag>Ubuntu</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Headless Raspberry Pi Setup]]></title>
    <url>%2F2017%2F05%2F09%2Fheadless-raspberry-pi-setup%2F</url>
    <content type="text"><![CDATA[li p { margin: 0; } Install Download “RASPBIAN JESSIE LITE” without PIXEL desktop. Unzip it to get the image file (.img) for writing to your SD card. Setup headless settings, if don’t have an extra keyboard or HDMI cable. Add “ssh” file to the SD card root. Then boot your Pi. Connect it to the router with wire. Then get its ip from the router. Use SSH to connect to your Pi. ssh pi@&lt;IP&gt;, password: raspberry. Configure your Pi. sudo raspi-config Setting WIFI up and reboot wireless. sudo vi /etc/wpa_supplicant/wpa_supplicant.conf 123456network=&#123; ssid=&quot;ssid&quot; psk=&quot;password&quot; priority=1 id_str=&quot;home&quot;&#125; sudo reboot Setting static ip. ifconfig sudo nano /etc/dhcpcd.conf1234# Custom static IP addressinterface wlan0static ip_address = 192.168.1.121/24static routers = 192.168.1.9 Writing the image to the SD card, see the guide for your system: Linux Mac OS Windows Installation Guide Headless Raspberry Pi Setup Mac下安装树莓派系统raspbian Prepare1sudo apt-get update Vim1234567891011121314151617# vimsudo apt-get remove vim-commonsudo apt-get install vim# config vimsudo vi /etc/vim/vimrc# 显示行号set nu# tab 退四格set tabstop=4# 语法高亮syntax on# 显示空白符# http://stackoverflow.com/questions/1675688/make-vim-show-all-white-spaces-as-a-character# howto: http://vimsheet.com/ Samba123456789101112131415# sambasudo apt-get install samba samba-common-bin# config sambasudo vi /etc/samba/smb.conf[homes] read only = no# restartsudo /etc/init.d/samba restart# add usersudo smbpasswd -a pi# Connect it under &quot;Shared of Finder on Mac&quot; Python1234567891011121314151617181920python --version# pipwhich pipcurl -O https://bootstrap.pypa.io/get-pip.pysudo python get-pip.py# config pipvi ~/.pip/pip.conf[global]format=columnsindex-url = https://mirrors.aliyun.com/pypi/simple/trusted-host = mirrors.aliyun.compip list [--outdated]sudo pip install --upgrade (package)# GPIOsudo pip install RPi.GPIO Then1sudo apt-get remove UsageLight a LED and so on. RPi.GPIO: https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/ vi led.py: 1234567891011121314151617181920#!/usr/bin/env python# -*- coding:utf-8 -*-import RPi.GPIO as GPIOimport timeprint(GPIO.RPI_INFO)LED = 26GPIO.setmode(GPIO.BCM)GPIO.setup(LED, GPIO.OUT)try: while True: GPIO.output(LED, GPIO.HIGH) time.sleep(1) GPIO.output(LED, GPIO.LOW) time.sleep(1)except: print(&quot;except&quot;)GPIO.cleanup() vi key.py: 123456789101112131415#!/usr/bin/env python# -*- coding:utf-8 -*-import RPi.GPIO as GPIOimport timeKEY = 20GPIO.setmode(GPIO.BCM)GPIO.setup(KEY, GPIO.IN, GPIO.PUD_UP)while True: time.sleep(0.05) if GPIO.input(KEY) == 0: print(&quot;KEY PRESS&quot;) while GPIO.input(KEY) == 0: time.sleep(0.01) vi event.py: 12345678910111213141516#!/usr/bin/env python# -*- coding:utf-8 -*-import RPi.GPIO as GPIOimport timeKEY = 20def MyInterrupt(KEY): print(&quot;KEY PRESS&quot;)GPIO.setmode(GPIO.BCM)GPIO.setup(KEY, GPIO.IN, GPIO.PUD_UP)GPIO.add_event_detect(KEY, GPIO.FALLING, MyInterrupt, 200)while True: time.sleep(1)]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Build OpenCV for Android with CUDA]]></title>
    <url>%2F2017%2F05%2F05%2Fbuild-ocv-for-android-with-cuda%2F</url>
    <content type="text"><![CDATA[Prerequisites Ubuntu 14.04 LTS Download here NVIDIA CodeWorks for Android 1R4 Doc here Download here Could only select actions: CUDA ToolKit 7.0, CUDA for Android 7.0 Android Studio Add C and C++ Code to Your Project Prepare1234567891011121314151617181920# Set environment variables$ vi ~/.bashrc# Android SDK &amp; NDKexport ANDROID_SDK=$HOME/Android/Sdkexport ANDROID_NDK=$ANDROID_SDK/ndk-bundleexport ANDROID_STANDALONE_TOOLCHAIN=$ANDROID_NDK/toolchainsexport PATH=$PATH:$ANDROID_SDK/tools:$ANDROID_SDK/tools/bin:$ANDROID_SDK/platform-tools:$ANDROID_NDK# Java SDK 1.8 (could ignore, for latest android command-line tool)export JAVA_HOME=$HOME/Develop/jdk1.8.0_131export PATH=$JAVA_HOME/bin:$PATH$ source ~/.bashrc# Enable OpenCV Java wrappers$ sudo apt-get install ant# Downgrade android command-line tool$ cd $ANDROID_SDK$ mv tools/ tools-backup/$ curl -O https://dl.google.com/android/repository/tools_r25.2.3-linux.zip$ unzip -q tools_r25.2.3-linux.zip Build 12345678910111213141516171819202122$ cd opencv-3.2.0/platforms/$ mkdir -p build_android_arm$ cd build_android_arm/$ cmake -DCMAKE_BUILD_TYPE=RELEASE \-DCMAKE_BUILD_WITH_INSTALL_RPATH=ON \-DCMAKE_TOOLCHAIN_FILE=../android/android.toolchain.cmake \\-DCUDA_TOOLKIT_ROOT_DIR=$HOME/NVPACK/cuda-7.0 \-DCUDA_ARCH_BIN=&quot;5.3&quot; \-DCUDA_ARCH_PTX=&quot;&quot; \-DCUDA_FAST_MATH=ON \-DWITH_CUDA=ON \-DWITH_CUFFT=OFF \-DWITH_CUBLAS=OFF \-DWITH_OPENCL=OFF \\-DBUILD_SHARED_LIBS=OFF \-DBUILD_DOCS=OFF \-DBUILD_EXAMPLES=OFF \-DBUILD_TESTS=OFF \-DBUILD_PERF_TESTS=OFF \../.. Result: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105-- General configuration for OpenCV 3.2.0 =====================================-- Version control: unknown---- Platform:-- Timestamp: 2017-05-05T05:05:05Z-- Host: Linux 4.4.0-75-generic x86_64-- Target: Linux 1 armv7-a-- CMake: 2.8.12.2-- CMake generator: Unix Makefiles-- CMake build tool: /usr/bin/make-- Configuration: RELEASE---- C/C++:-- Built as dynamic libs?: NO-- C++ Compiler: /home/john/Android/Sdk/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-g++ (ver 4.9)-- C++ flags (Release): -fexceptions -frtti -fpic -Wno-psabi --sysroot=/home/john/Android/Sdk/ndk-bundle/platforms/android-9/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Wa,--noexecstack -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -fomit-frame-pointer -mfp16-format=ieee -fvisibility=hidden -fvisibility-inlines-hidden -mthumb -fomit-frame-pointer -fno-strict-aliasing -O3 -DNDEBUG -DNDEBUG-- C++ flags (Debug): -fexceptions -frtti -fpic -Wno-psabi --sysroot=/home/john/Android/Sdk/ndk-bundle/platforms/android-9/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Wa,--noexecstack -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wundef -Winit-self -Wpointer-arith -Wshadow -Wsign-promo -Wno-narrowing -Wno-delete-non-virtual-dtor -Wno-comment -fdiagnostics-show-option -fomit-frame-pointer -mfp16-format=ieee -fvisibility=hidden -fvisibility-inlines-hidden -marm -fno-omit-frame-pointer -fno-strict-aliasing -O0 -g -DDEBUG -D_DEBUG -O0 -DDEBUG -D_DEBUG-- C Compiler: /home/john/Android/Sdk/ndk-bundle/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc-- C flags (Release): -fexceptions -fpic -Wno-psabi --sysroot=/home/john/Android/Sdk/ndk-bundle/platforms/android-9/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Wa,--noexecstack -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wno-narrowing -Wno-comment -fdiagnostics-show-option -fomit-frame-pointer -mfp16-format=ieee -fvisibility=hidden -mthumb -fomit-frame-pointer -fno-strict-aliasing -O3 -DNDEBUG -DNDEBUG-- C flags (Debug): -fexceptions -fpic -Wno-psabi --sysroot=/home/john/Android/Sdk/ndk-bundle/platforms/android-9/arch-arm -funwind-tables -finline-limit=64 -fsigned-char -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -fdata-sections -ffunction-sections -Wa,--noexecstack -fsigned-char -W -Wall -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -Wformat -Werror=format-security -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wundef -Winit-self -Wpointer-arith -Wshadow -Wno-narrowing -Wno-comment -fdiagnostics-show-option -fomit-frame-pointer -mfp16-format=ieee -fvisibility=hidden -marm -fno-omit-frame-pointer -fno-strict-aliasing -O0 -g -DDEBUG -D_DEBUG -O0 -DDEBUG -D_DEBUG-- Linker flags (Release): -Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,-allow-shlib-undefined -Wl,--gc-sections -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now-- Linker flags (Debug): -Wl,--fix-cortex-a8 -Wl,--no-undefined -Wl,-allow-shlib-undefined -Wl,--gc-sections -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now-- ccache: YES-- Precompiled headers: NO-- Extra dependencies: z dl m log cudart nppc nppi npps -L/home/john/NVPACK/cuda-7.0/targets/armv7-linux-androideabi/lib -L/home/john/NVPACK/cuda-7.0/targets/armv7-linux-androideabi/lib/stubs-- 3rdparty dependencies: libjpeg libwebp libpng libtiff libjasper IlmImf tegra_hal---- OpenCV modules:-- To be built: cudev core cudaarithm flann imgproc ml video cudabgsegm cudafilters cudaimgproc cudawarping imgcodecs photo shape videoio cudacodec highgui objdetect features2d calib3d cudafeatures2d cudalegacy cudaobjdetect cudaoptflow cudastereo java stitching superres videostab-- Disabled: world-- Disabled by dependency: --- Unavailable: python2 ts viz---- Android:-- Android ABI: armeabi-v7a-- STL type: gnustl_static-- Native API level: android-9-- SDK target: android-21-- Android NDK: /home/john/Android/Sdk/ndk-bundle (toolchain: arm-linux-androideabi-4.9)-- android tool: /home/john/Android/Sdk/tools/android (Android SDK Tools, revision 25.2.3.)-- Google Play manager: NO-- Android examples: YES---- GUI:-- GTK+: NO-- GThread : NO-- GtkGlExt: NO-- OpenGL support: NO-- VTK support: NO---- Media I/O:-- ZLib: z (ver 1.2.3)-- JPEG: build (ver 90)-- WEBP: build (ver 0.3.1)-- PNG: build (ver 1.6.24)-- TIFF: build (ver 42 - 4.0.2)-- JPEG 2000: build (ver 1.900.1)-- OpenEXR: build (ver 1.7.1)-- GDAL: NO-- GDCM: NO---- Video I/O:---- Parallel framework: pthreads---- Other third-party libraries:-- Use IPP: NO-- Use Eigen: YES (ver 3.2.0)-- Use Cuda: YES (ver 7.0)-- Use OpenCL: NO-- Use OpenVX: NO-- Use custom HAL: YES (carotene (ver 0.0.1))---- NVIDIA CUDA-- Use CUFFT: NO-- Use CUBLAS: NO-- USE NVCUVID: NO-- NVIDIA GPU arch: 53-- NVIDIA PTX archs:-- Use fast math: YES---- Python 2:-- Interpreter: /usr/bin/python2.7 (ver 2.7.6)---- Python 3:-- Interpreter: /usr/bin/python3.4 (ver 3.4.3)---- Python (for build): /usr/bin/python2.7---- Java:-- ant: /usr/bin/ant (ver 1.9.3)-- Java wrappers: YES-- Java tests: NO---- Matlab: NO---- Tests and samples:-- Tests: NO-- Performance tests: NO-- C/C++ Examples: NO---- Install path: /home/john/Workspace/opencv-3.2.0/platforms/build_android_arm/install---- cvconfig.h is in: /home/john/Workspace/opencv-3.2.0/platforms/build_android_arm-- ----------------------------------------------------------------- Make: 123$ make -j8# Or,$ make -j$(python -c &apos;import multiprocessing as mp; print(mp.cpu_count())&apos;) Alternatives (ignored): 12345$ cd opencv-3.2.0/platforms/$ ./scripts/cmake_android_arm.sh# Tegra X1: https://developer.nvidia.com/content/tegra-x1-D CUDA_GENERATION=Maxwell UsageOpen “Android Studio” and, “Import Module” from “build_android_arm” directory. Exclude “jni”, only keep “aidl”, “java”, “res/values/attrs.xml” Ensure it’s the same file structure as the offical OpenCV4Android. About the sample project, you could find here. IssuesIssue when cmakeFailed to get list of installed Android targets. CMake Warning at cmake/OpenCVDetectAndroidSDK.cmake:205 (message): Can not find any SDK target compatible with: 9 11 And, 12345678910111213141516171819202122$ android list target -c*************************************************************************The &quot;android&quot; command is deprecated.For manual SDK, AVD, and project management, please use Android Studio.For command-line tools, use tools/bin/sdkmanager and tools/bin/avdmanager*************************************************************************Running /home/john/Android/Sdk/tools/bin/avdmanager list target -cException in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/android/sdklib/tool/AvdManagerCli : Unsupported major.minor version 52.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:803) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:442) at java.net.URLClassLoader.access$100(URLClassLoader.java:64) at java.net.URLClassLoader$1.run(URLClassLoader.java:354) at java.net.URLClassLoader$1.run(URLClassLoader.java:348) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:347) at java.lang.ClassLoader.loadClass(ClassLoader.java:425) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:358) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:482) Solution: Install Java SDK 1.8 Fix “UnsupportedClassVersionError …” Amend match of android sdk targets 1234$ cd opencv-3.2.0/$ vi cmake/OpenCVDetectAndroidSDK.cmake# line 98, change &quot;[^\n]+&quot; to &quot;android-[0-9]+&quot;string(REGEX MATCHALL &quot;android-[0-9]+&quot; ANDROID_SDK_TARGETS &quot;$&#123;ANDROID_SDK_TARGETS&#125;&quot;) Or, cmake with -DANDROID_EXECUTABLE=$ANDROID_SDK/tools/bin/avdmanager WARN： However, make still will fail in “Generating OpenCV Android library project.” Issue when make[ 92%] Generating OpenCV Android library project. SDK target: android-21 ************************************************************************* The &quot;android&quot; command is deprecated. For manual SDK, AVD, and project management, please use Android Studio. For command-line tools, use tools/bin/sdkmanager and tools/bin/avdmanager ************************************************************************* Invalid or unsupported command &quot;--silent create lib-project --path /home/john/Workspace/opencv-3.2.0/platforms/build_android_arm --target android-21 --name OpenCV --package org.opencv&quot; Supported commands are: android list target android list avd android list device android create avd android move avd android delete avd android list sdk android update sdk make[2]: *** [build.xml] Error 2 make[1]: *** [modules/java/CMakeFiles/opencv_java.dir/all] Error 2 make: *** [all] Error 2 Solution: Downgrade android command-line tool 12345$ cd $ANDROID_SDK$ mv tools/ tools-backup/$ curl -O https://dl.google.com/android/repository/tools_r25.2.3-linux.zip$ unzip -q tools_r25.2.3-linux.zip Learn more: Tools 25.3.1 deprecation of ‘android’ command line tool breaks Unity3D build References OpenCV Platforms Android Building OpenCV4Android from trunk Building OpenCV &amp; OpenCV Extra Modules For Android From Source Building OpenCV for Tegra with CUDA]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>CUDA</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use ccache, distcc, dmucs to accelerate builds]]></title>
    <url>%2F2017%2F05%2F05%2Fuse-ccache-distcc-dmucs-to-accelerate-builds%2F</url>
    <content type="text"><![CDATA[ccacheccache is a compiler cache. It speeds up recompilation by caching previous compilations and detecting when the same compilation is being done again. Supported languages are C, C++, Objective-C and Objective-C++. Mac: 123456789101112131415161718# install$ brew install ccache# where$ brew ls ccache$ which ccache$ brew info ccache# env$ vi ~/.bash_profile export PATH=/usr/local/opt/ccache/libexec:$PATH# verify$ source ~/.bash_profile$ which clang/usr/local/opt/ccache/libexec/clang Ubuntu: 1234567891011121314151617# install$ sudo apt-get install ccache# where$ whereis ccache$ which ccache# env$ vi ~/.bashrc export PATH=/usr/lib/ccache:$PATH# verify$ source ~/.bashrc$ which g++ gcc/usr/lib/ccache/g++/usr/lib/ccache/gcc Using CCache on Mac distcc on Ubuntudistcc is a program to distribute compilation of C or C++ code across several machines on a network. distcc should always generate the same results as a local compile, is simple to install and use, and is often two or more times faster than a local compile. Install: 123456789101112131415161718192021222324# install$ sudo apt-get install distcc# optional$ sudo apt-get install distccmon-gnome$ distcc --help# show ip$ ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1192.168.199.247# config$ sudo vi /etc/default/distcc STARTDISTCC=&quot;true&quot; ALLOWEDNETS=&quot;192.168.0.0/16&quot; LISTENER=&quot;&quot; ZEROCONF=&quot;false&quot;# start server$ sudo /etc/init.d/distcc start# reboot &amp; verify$ ps aux | grep distccd Usage: 1234567891011121314151617181920# download$ curl -R -O http://www.lua.org/ftp/lua-5.3.4.tar.gz$ tar zxf lua-5.3.4.tar.gz$ cd lua-5.3.4# build$ time make linux# clean$ make clean; ccache -C# display distcc jobs, plz in another terminal$ distccmon-text 2# or, with gui$ distccmon-gnome &amp;# build with distcc$ export DISTCC_HOSTS=&quot;192.168.199.247 192.168.199.104&quot;$ time make -j12 CC=&quot;distcc gcc -std=gnu99&quot; linux Cost: normal ccache distcc distcc + ccache cost 4.069s 0.134s 1.301s 1.296s P.S. distcc: 2 quad-core pc, -j12 normal make make -j4 cost 4.069s 1.403s Use with ccache: NOTE: This use of ccache is incompatible with use of distcc’s “pump” mode. distcc on MacInstall: 1234567891011121314151617181920212223242526272829# install$ brew install distcc$ brew info distcc$ distcc --help$ distccd --help# show ip$ ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1192.168.199.182# config$ vi /usr/local/Cellar/distcc/3.2rc1/homebrew.mxcl.distcc.plist ... &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/opt/distcc/bin/distccd&lt;/string&gt; &lt;string&gt;--daemon&lt;/string&gt; &lt;string&gt;--no-detach&lt;/string&gt; &lt;string&gt;--allow=192.168.0.0/16&lt;/string&gt; &lt;/array&gt; ...# start server$ brew services start distcc# reboot &amp; verify$ ps aux | grep distccd Usage: 1234567891011121314151617181920212223# download$ curl -R -O http://www.lua.org/ftp/lua-5.3.4.tar.gz$ tar zxf lua-5.3.4.tar.gz$ cd lua-5.3.4# build$ time make macosx# clean$ make clean; ccache -C# display distcc jobs, plz in another terminal$ distccmon-text 2# build with distcc$ export DISTCC_HOSTS=&quot;192.168.199.182 192.168.199.105&quot;$ vi src/Makefile macosx: $(MAKE) $(ALL) SYSCFLAGS=&quot;-DLUA_USE_MACOSX&quot; SYSLIBS=&quot;-lreadline&quot; CC=&quot;distcc cc&quot;$ time make -j12 macosx Note: It is recommended that using distcc splits different platforms. dmucs on UbuntuDMUCS is a system that allows a group of users to share a compilation farm. Each compilation request from each user will be sent to the fastest available machine, every time. Install: 1234567891011121314151617# install$ sudo apt-get install dmucs# bug fix for restart on boot# dmucs: race condition in start scripts prevents loadavg starting# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=798830$ sudo vi /etc/init.d/dmucs start) if [ &quot;$SERVER&quot; = &quot;yes&quot; ]; then ... if start_server ; then ... if [ &quot;$USE_SERVER&quot; ]; then ... if start_loadavg ; then ... P.S. Unfortunately, this fix doesn’t work on my Ubuntu, although start_loadavg result is ok ==. You could log the output of “/etc/init.d/dmucs” script, add this at the top: 12exec 1&gt;/tmp/init.log 2&gt;&amp;1set -x Server machine (e.g. 192.168.199.210): 12345678910111213141516171819202122# config$ sudo vi /etc/default/dmucs SERVER=yes USE_SERVER=# hosts-info$ sudo vi /etc/dmucs.conf # Format: machine number-of-cpus power-index 192.168.199.104 4 8 192.168.199.247 4 10# start$ sudo /etc/init.d/dmucs start# verify restart on boot$ sudo reboot$ ps aux | grep dmucs# display which hosts/cpus are available$ monitor Each host (e.g. 192.168.199.104 192.168.199.247): 123456789101112# config$ sudo vi /etc/default/dmucs SERVER=no USE_SERVER=192.168.199.210# start$ sudo /etc/init.d/dmucs start# verify restart on boot$ sudo reboot$ ps aux | grep loadavg Usage: 1234$ cd lua-5.3.4# build$ time make -j12 CC=&quot;gethost -s 192.168.199.210 distcc gcc -std=gnu99&quot; linux Issue: loadavg get wrong host on Ubuntu 14.04, then dmucs not recognize the hostsRun loadavg -s 192.168.199.210 -D, see “Writing –&gt;127.0.1.1 …&lt;– to the server”. Easily avoid this issue as follows: 123456789# comment host &quot;127.0.1.1&quot;$ sudo vi /etc/hosts 127.0.0.1 localhost #127.0.1.1 ubuntu ...# restart loadavg$ sudo /etc/init.d/dmucs restart However, it will affect dnsmasq at least. Learn more, plz google “127.0.1.1”, “ubuntu dnsmasq 127.0.1.1”.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>ccache</tag>
        <tag>distcc</tag>
        <tag>dmucs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install Caffe & TensorFlow with Python and CUDA (macOS)]]></title>
    <url>%2F2017%2F04%2F12%2Finstall-caffe-tf%2F</url>
    <content type="text"><![CDATA[RequirementsPython Installationpyenv 1234567$ brew install pyenv$ pyenv install --list$ pyenv install anaconda3-4.3.1$ pyenv global anaconda3-4.3.1$ pyenv versions system* anaconda3-4.3.1 (set by /Users/John/.pyenv/version) Enable pyenv in your shell: 123$ vi ~/.bash_profile# eval &quot;$(pyenv init -)&quot;$ exit 123456$ python --versionPython 3.6.0 :: Anaconda 4.3.1 (x86_64)$ pip --versionpip 9.0.1 from /Users/John/.pyenv/versions/anaconda3-4.3.1/lib/python3.6/site-packages (python 3.6)$ conda --versionconda 4.3.14 CUDA Installation For Mac OS X, please see Setup GPU for Mac CUDA Toolkit 8.0 cuDNN v5 1234$ sudo mv include/cudnn.h /Developer/NVIDIA/CUDA-8.0/include/$ sudo mv lib/libcudnn* /Developer/NVIDIA/CUDA-8.0/lib$ sudo ln -s /Developer/NVIDIA/CUDA-8.0/lib/libcudnn* /usr/local/cuda/lib/$ sudo ln -s /usr/local/cuda/lib/libcuda.dylib /usr/local/cuda/lib/libcuda.1.dylib OpenCV Installation1$ curl -O https://github.com/opencv/opencv/archive/3.2.0.zip 123456789101112131415161718$ cd opencv$ mkdir build$ cd build/$ PY3_DIR=$HOME/.pyenv/versions/anaconda3-4.3.1 &amp;&amp; \export CPLUS_INCLUDE_PATH=$PY3_DIR/include/python3.6m &amp;&amp; \cmake -D CMAKE_BUILD_TYPE=RELEASE \-D CMAKE_INSTALL_PREFIX=/usr/local \-D PYTHON3_LIBRARY=$PY3_DIR/lib \-D PYTHON3_INCLUDE_DIR=$PY3_DIR/include/python3.6m \-D PYTHON3_EXECUTABLE=$HOME/.pyenv/shims/python \-D BUILD_opencv_python2=OFF \-D BUILD_opencv_python3=ON \-D BUILD_EXAMPLES=ON \-D INSTALL_PYTHON_EXAMPLES=OFF \-D INSTALL_C_EXAMPLES=OFF \..$ make -j8$ make install Issue fixed by export CPLUS_INCLUDE_PATH=$PY3_DIR/include/python3.6m: [ 73%] Building CXX object modules/python3/CMakeFiles/opencv_python3.dir/__/src2/cv2.cpp.o /Users/John/Workspace/Fever/Vision/opencv/modules/python/src2/cv2.cpp:6:10: fatal error: &apos;Python.h&apos; file not found #include &lt;Python.h&gt; ^ 1 error generated. CaffeInstallation1$ brew install -vd snappy leveldb gflags glog szip lmdb 1234# with Python pycaffe needs dependencies built from source$ brew install --build-from-source -vd protobuf --with-python$ brew install --build-from-source -vd boost$ brew install --build-from-source -vd boost-python --with-python3 --without-python Compilation 123$ git clone https://github.com/BVLC/caffe.git$ cd caffe/$ git checkout rc5 12$ cp Makefile.config.example Makefile.config# Adjust Makefile.config (for example, if using Anaconda Python, or if cuDNN is desired) USE_CUDNN := 1 OPENCV_VERSION := 3 # brew install openblas BLAS := open BLAS_INCLUDE := $(shell brew --prefix openblas)/include BLAS_LIB := $(shell brew --prefix openblas)/lib # PYTHON_INCLUDE := /usr/include/python2.7 \ # /usr/lib/python2.7/dist-packages/numpy/core/include ANACONDA_HOME := $(HOME)/.pyenv/versions/anaconda3-4.3.1 PYTHON_INCLUDE := $(ANACONDA_HOME)/include \ $(ANACONDA_HOME)/include/python3.6m \ $(ANACONDA_HOME)/lib/python3.6/site-packages/numpy/core/include # ll /usr/local/lib/*boost*py* PYTHON_LIBRARIES := boost_python3 python3.6m # PYTHON_LIB := /usr/lib PYTHON_LIB := $(ANACONDA_HOME)/lib WITH_PYTHON_LAYER := 1 12$ make all -j8$ make pycaffe -j8 123456789$ vi ~/.bash_profile# export PYTHONPATH=$HOME/Workspace/Fever/DeepLearning/caffe/python:$PYTHONPATH$ python&gt;&gt;&gt; import caffe&gt;&gt;&gt; caffe.__version__&apos;1.0.0-rc5&apos;# Or,$ python -c &quot;import caffe; print(caffe.__version__)&quot;1.0.0-rc5 IssuesIssue, make pycaffe:Undefined symbols for architecture x86_64: &quot;boost::python::detail::init_module(PyModuleDef&amp;, void (*)())&quot;, referenced from: _PyInit__caffe in _caffe-57cf03.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) make: *** [python/caffe/_caffe.so] Error 1 Solution: 12$ brew info boost-python$ brew reinstall boost-python --with-python3 --without-python Issue, import caffe:&gt;&gt;&gt; import caffe Failed to include caffe_pb2, things might go wrong! Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/Users/John/Workspace/Fever/DeepLearning/caffe/python/caffe/__init__.py&quot;, line 4, in &lt;module&gt; from .proto.caffe_pb2 import TRAIN, TEST File &quot;/Users/John/Workspace/Fever/DeepLearning/caffe/python/caffe/proto/caffe_pb2.py&quot;, line 6, in &lt;module&gt; from google.protobuf.internal import enum_type_wrapper ModuleNotFoundError: No module named &apos;google&apos; Solution: 1$ pip install protobuf # https://anaconda.org/anaconda/protobuf/files $ conda install protobuf Fetching package metadata ......... Solving package specifications: . UnsatisfiableError: The following specifications were found to be in conflict: - protobuf -&gt; python 2.7* -&gt; openssl 1.0.1* - python 3.6* Use &quot;conda info &lt;package&gt;&quot; to see the dependencies for each package. OthersHow display dependencies: 123$ cd build/lib/# ldd -r libcaffe.so.1.0.0-rc5$ otool -L libcaffe.so.1.0.0-rc5 TensorFlowInstallation12345$ pip install tensorflow-gpu# Or,# tensorflow-gpu: https://pypi.python.org/pypi/tensorflow-gpu$ export TF_BINARY_URL=https://pypi.python.org/packages/d6/54/f7cf39483b16c25a8c132dc0b81aea2ae91e367da749f17dddeaf739123a/tensorflow_gpu-1.1.0rc1-cp36-cp36m-macosx_10_11_x86_64.whl$ pip install --upgrade $TF_BINARY_URL 123456789101112$ python...&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print(sess.run(hello))Hello, TensorFlow!&gt;&gt;&gt; a = tf.constant(10)&gt;&gt;&gt; b = tf.constant(32)&gt;&gt;&gt; print(sess.run(a + b))42&gt;&gt;&gt; IssuesIssue, import tensorflow:&gt;&gt;&gt; import tensorflow as tf I tensorflow/stream_executor/dso_loader.cc:135] successfully opened CUDA library libcublas.8.0.dylib locally I tensorflow/stream_executor/dso_loader.cc:135] successfully opened CUDA library libcudnn.5.dylib locally I tensorflow/stream_executor/dso_loader.cc:135] successfully opened CUDA library libcufft.8.0.dylib locally Segmentation fault: 11 Solution: 1$ sudo ln -s /usr/local/cuda/lib/libcuda.dylib /usr/local/cuda/lib/libcuda.1.dylib Installing Tensorflow with GPU support on os x 10.11 Issue, “Library not loaded: @rpath/libcublas.8.0.dylib”:ImportError: dlopen(/Users/John/.pyenv/versions/anaconda3-4.3.1/lib/python3.6/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so, 10): Library not loaded: @rpath/libcublas.8.0.dylib Solution: Disbale SIP Reboot into “Recovery OS”, 1$ csrutil disable Restart into macOS, 12$ python -c &quot;import tensorflow; print(tensorflow.__version__)&quot;1.1.0-rc1 References Awesome TensorFlow]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Caffe</tag>
        <tag>TensorFlow</tag>
        <tag>Python</tag>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Djinni 开发 Android, iOS 共享库]]></title>
    <url>%2F2016%2F05%2F06%2Fusing-djinni%2F</url>
    <content type="text"><![CDATA[.post-body .fancybox img { margin: 0 auto 25px; } Djinni 是一个用来生成跨语言的类型声明和接口绑定的工具，主要用于 C++ 和 Java 以及 Objective-C 间的互通。 此文，将介绍如何使用 Djinni 开发 Android, iOS 的共享库。这会带来几个好处： 用了接口描述文件。声明清晰、修改简易，并保证了跨平台接口的一致性。 自动生成接口绑定代码。免去了绑定 C++ 和 Java (JNI) 及 Objective-C (Objective-C++) 的麻烦。 初见：Djinni 及其样例下载 Djinni1$ git clone https://github.com/dropbox/djinni.git 编译 Djinni12$ cd [djinni_root]/$ src/build 于[djinni_root]/src/support/sbt.resolvers.properties内可添加镜像源。 sbt下载慢？ 使用 Djinni 生成样例接口代码： 12$ cd [djinni_root]/example/ # example_root$ ./run_djinni.sh 即会生成到djinni-output-temp临时目录，最终复制到generated-src生成目录。 这里可以看到：依据描述文件example.djinni，C++ 和 Java 及 Objective-C 的绑定代码都会自动生成好。继续要做的，只是写它们的具体实现，见样例的handwritten-src目录。 如果要清除输出目录： 1$ ./run_djinni.sh clean 编译样例[djinni_root]/Makefile已配置好了依赖，执行相应目标即可。 1$ cd [djinni_root]/ 注：下载好 Djinni ，即可开始编译样例了。 编译 Android 工程： 1$ make example_android 样例的 Android 工程在[example_root]/android目录， 动态库生成在[example_root]/android/app/libs目录。或者，利用 Android Studio / Gradle 来运行编译。 编译 iOS 工程： 1$ make example_ios 样例的 iOS 工程在[example_root]/objc目录， lib 工程生成在[djinni_root]\build_ios目录。然后，可以打开[example_root]/objc/TextSort.xcworkspace来运行编译。 如果要清理工程： 1$ make clean 准备 GYP编译样例时， Android NDK 与 iOS 的 Library 工程都需依赖 GYP 生成。 make 时，会自行 clone 到[djinni_root]/deps/gyp目录。 1$ git clone https://chromium.googlesource.com/external/gyp.git GYP 生成 Android Makefile 时，目前会遇到如下错误： ImportError: No module named android 所以，需要切换到旧版本。此后的那个 commit 移除了 Android 的生成器。 12$ cd gyp/$ git checkout -q 0bb67471bca068996e15b56738fa4824dfa19de0 注：Stop using gyp’s android generator 从无到有：Hello DjinniC++ 接口定义接口描述文件hellodjinni.djinnihellodjinni.djinni1234hello_djinni = interface +c &#123; static create(): hello_djinni; get_hello_djinni(): string;&#125; 生成接口绑定代码写了个简单的 Shell 脚本来执行 Djinni 命令，如下： run_djinni.sh:run_djinni.sh12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/bashset -eshopt -s nullglobbase_dir=$(cd "`dirname "$0"`" &amp;&amp; pwd)# Read local propertieseval $(cat $base_dir/local.properties | sed 's/&lt;[^&gt;]*&gt;//g' | sed 's/\./_/g')if [[ -z $djinni_dir ]]; then echo "Unspecified djinni.dir in local.properties" 1&gt;&amp;2 exit 1fiout_dir="$base_dir/generated-src"cpp_out="$out_dir/cpp"jni_out="$out_dir/jni"objc_out="$out_dir/objc"java_out="$out_dir/java/cc/eevee/hellodjinni"java_package="cc.eevee.hellodjinni"cpp_namespace="hellodjinni"objc_type_prefix="HD"djinni_file="$base_dir/hellodjinni.djinni"[[ -e $out_dir ]] &amp;&amp; rm -rf $out_dir$djinni_dir/src/run-assume-built \ --java-out $java_out \ --java-package $java_package \ --ident-java-field mFooBar \ \ --cpp-out $cpp_out \ --cpp-namespace $cpp_namespace \ \ --jni-out $jni_out \ --ident-jni-class NativeFooBar \ --ident-jni-file NativeFooBar \ \ --objc-out $objc_out \ --objcpp-out $objc_out \ --objc-type-prefix $objc_type_prefix \ \ --idl $djinni_file 其读取了local.properties内配置的 Djinni 目录路径。 local.propertieslocal.properties123djinni.dir=&lt;path-to-djinni&gt;gyp.dir=&lt;path-to-gyp&gt;ndk.dir=&lt;path-to-ndk&gt; 运行后，代码生成在了generated-src目录。 1$ ./run_djinni.sh 实现 C++ 接口首先，创建src目录，存放手写的代码。然后，于子目录cpp内实现 C++ 接口。 src/cpp/hello_djinni_impl.hpphello_djinni_impl.hpp12345678910111213141516#pragma once#include "hello_djinni.hpp"namespace hellodjinni &#123;class HelloDjinniImpl : public HelloDjinni &#123;public: // Constructor HelloDjinniImpl(); // Our method that returns a string std::string get_hello_djinni();&#125;;&#125; // namespace hellodjinni src/cpp/hello_djinni_impl.cpphello_djinni_impl.cpp12345678910111213141516171819202122232425#include "hello_djinni_impl.hpp"#include &lt;string&gt;using namespace hellodjinni;std::shared_ptr&lt;HelloDjinni&gt; HelloDjinni::create() &#123; return std::make_shared&lt;HelloDjinniImpl&gt;();&#125;HelloDjinniImpl::HelloDjinniImpl() &#123;&#125;std::string HelloDjinniImpl::get_hello_djinni() &#123; std::string result = "Hello Djinni! "; time_t t = time(0); tm now = *localtime(&amp;t); char tm_desc[200] = &#123;0&#125;; if (strftime(tm_desc, sizeof(tm_desc)-1, "%r", &amp;now)&gt;0) &#123; result += tm_desc; &#125; return result;&#125; C++ 工程这里用 XCode 创建一个 C++ 工程，来测试 C++ 接口代码。 首先，打开 XCode ，选择”Create a new Xcode project”。然后，选择”Command Line Tool”，来新建命令行工具。 {% asset_img cpp_pro_new.png %} “Next”到下一步时，”Language”选择”C++”。 {% asset_img cpp_pro_new_2.png %} 工程最后保存到了project/cpp目录。整个文件结构如下： 接下来，把以下 C++ 接口代码文件，拖动到 XCode 工程目录来引入。 123generated-src/cpp/hello_djinni.hppsrc/cpp/hello_djinni_impl.cppsrc/cpp/hello_djinni_impl.hpp 注：取消”Copy items if needed”，选择”Create folder references”。只需引用文件，避免复制。 然后，编写好main.cpp的代码： project/cpp/HelloDjinni/HelloDjinni/main.cppmain.cpp123456789101112#include &lt;iostream&gt;#include "hello_djinni_impl.hpp"int main(int argc, const char * argv[]) &#123; typedef hellodjinni::HelloDjinni HelloDjinni; auto hd = HelloDjinni::create(); auto result = hd-&gt;get_hello_djinni(); std::cout &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 最后，运行项目，结果如下： {% asset_img cpp_pro_overview.png %} 或者，写个project/Cpp.mk： project/Cpp.mkCpp.mk1234567891011121314151617181920212223242526272829303132333435363738394041MD := -mkdir -pRD := -rm -rfRM := -rm -fCC := gccCXX := g++CXXFLAGS := -std=c++11 -Wallifdef DEBUGCXXFLAGS += -g -DDEBUGelseCXXFLAGS += -O2 -DNDEBUGendifOUT_DIR ?= buildCPP_OUT ?= $(OUT_DIR)/cppCPP_INCLUDES := \ ../generated-src/cpp \ ../src/cppCPP_SOURCES := \ ../src/cpp/hello_djinni_impl.cpp \ cpp/HelloDjinni/HelloDjinni/main.cppCPP_TARGET := $(CPP_OUT)/HelloDjinniall: cpp_proclean: $(RD) $(CPP_OUT)/cpp_pro: $(CPP_SOURCES) @echo "\033[1;35;47mBuild cpp project...\033[0m" @$(MD) $(CPP_OUT) $(CXX) $(CXXFLAGS) $(CPP_SOURCES) -o $(CPP_TARGET) \ $(foreach d, $(CPP_INCLUDES), -I$d) @echo "\033[32mOutput:\033[0m\n$(CPP_TARGET)" @echo "\033[32mRunning:\033[0m" @$(CPP_TARGET).PHONY: cpp_pro clean all 然后，make -f Cpp.mk编译运行，结果如下： 12345678910Build cpp project...g++ -std=c++11 -Wall -O2 -DNDEBUG \ ../src/cpp/hello_djinni_impl.cpp \ cpp/HelloDjinni/HelloDjinni/main.cpp \ -o build/cpp/HelloDjinni \ -I../generated-src/cpp -I../src/cppOutput:build/cpp/HelloDjinniRunning:Hello Djinni! 11:46:56 PM iOS 工程打开 XCode，”File &gt; New &gt; Workspace”新建一个工作区，保存到project/ios目录。 接着，”File &gt; New &gt; Project”，选择”Single View Application”，创建 iOS 工程。 “Next”到下一步时，”Language”选择”Objective-C”。 工程保存到project/ios目录，”Add to”选择刚才的工作区。 {% asset_img ios_pro_new_3.png %} “Create”完成创建。 生成接口 Libraries 工程利用 Djinni, GYP 及 Make 生成接口 Libraries 工程。 首先，创建 GYP 文件： project/libhellodjinni.gyplibhellodjinni.gyp12345678910111213141516171819202122232425262728293031323334353637383940&#123; "targets": [ &#123; "target_name": "libhellodjinni_jni", "type": "shared_library", "dependencies": [ "&lt;(DJINNI_DIR)/support-lib/support_lib.gyp:djinni_jni", ], "ldflags": [ "-llog", "-Wl,--build-id,--gc-sections,--exclude-libs,ALL" ], "sources": [ "&lt;(DJINNI_DIR)/support-lib/jni/djinni_main.cpp", "&lt;!@(python &lt;(DJINNI_DIR)/example/glob.py ../generated-src/jni '*.cpp')", "&lt;!@(python &lt;(DJINNI_DIR)/example/glob.py ../generated-src/cpp '*.cpp')", "&lt;!@(python &lt;(DJINNI_DIR)/example/glob.py ../src '*.cpp')", ], "include_dirs": [ "../generated-src/jni", "../generated-src/cpp", "../src/cpp", ], &#125;, &#123; "target_name": "libhellodjinni_objc", "type": "static_library", "dependencies": [ "&lt;(DJINNI_DIR)/support-lib/support_lib.gyp:djinni_objc", ], "sources": [ "&lt;!@(python &lt;(DJINNI_DIR)/example/glob.py ../generated-src/objc '*.cpp' '*.mm' '*.m')", "&lt;!@(python &lt;(DJINNI_DIR)/example/glob.py ../generated-src/cpp '*.cpp')", "&lt;!@(python &lt;(DJINNI_DIR)/example/glob.py ../src '*.cpp')", ], "include_dirs": [ "../generated-src/objc", "../generated-src/cpp", "../src/cpp", ], &#125;, ],&#125; 注意：1) sources内的路径必须是相对路径。虽然会识别以/开头的字符串为绝对路径，但在 XCode 工程内其路径引用是不正确的。2) GYP 生成 Android Makefile 时，运行命令时的工作目录，必须能够直接子目录到所有代码，包括依赖的 Djinni 的 support-lib 。不然，会报如下错误： AssertionError: Path %s attempts to escape from gyp path %s !) 👌的话，GypAndroid.mk会生成到当前工作目录。GYP 生成 Android 时，不允许指定--generator-output： AssertionError: The Android backend does not support options.generator_output. 所以，简单的解决办法是，文件结构与[djinni_root]/example一致，并git submodule Djinni 与 GYP 到工程目录内。 123$ git init$ git submodule add https://github.com/dropbox/djinni.git deps/djinni$ git submodule add https://chromium.googlesource.com/external/gyp.git deps/gyp 如果仍想要 Djinni 与 GYP 独立于工程目录外，同时又能够工作在工程目录，那么需要把依赖的东西复制进工程目录。之后，即是这样做的。 接下来，创建 Makefile 文件： project/MakefileMakefile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143MD := -mkdir -pRD := -rm -rfRM := -rm -fSED_PROP := "s/&lt;[^&gt;]*&gt;//g;s/.*=\(.*\)/\1/"define read_prop $(eval $(1) := $(shell ../tools/read_properties.sh \ | grep -m1 $(2) | sed $(SED_PROP)))endef$(call read_prop,GYP_DIR,gyp_dir)$(call read_prop,NDK_DIR,ndk_dir)OUT_DIR ?= buildIOS_OUT ?= $(OUT_DIR)/iosDEPS_DIR ?= depsDEPS_DJINNI_DIR := $(DEPS_DIR)/djinniDJINNI_OUT_DIR ?= ../generated-src.PHONY: allall: cpp_pro ios_pro android_pro android_pro2.PHONY: cleanclean: @make ios_pro_clean @make android_pro_clean @make android_pro2_clean @echo "\033[1;35;47mClean others...\033[0m" $(RD) $(OUT_DIR)/ $(RD) $(DEPS_DIR)/ $(RD) $(DJINNI_OUT_DIR)/ $(RM) ../GypAndroid.mk $(RM) libhellodjinni_jni.target.mk @# @make cpp_pro_cleandeps: @echo "\033[1;35;47mPrepare dependencies...\033[0m" @../tools/prepare_deps.sh $(DEPS_DIR)$(DJINNI_OUT_DIR): ../hellodjinni.djinni @echo "\033[1;35;47mGenerate djinni interface code...\033[0m" @../run_djinni.sh.PHONY: djinnidjinni: $(DJINNI_OUT_DIR).PHONY: cpp_procpp_pro: $(DJINNI_OUT_DIR) @make -f Cpp.mk cpp_pro.PHONY: cpp_pro_cleancpp_pro_clean: @make -f Cpp.mk clean$(IOS_OUT)/libhellodjinni.xcodeproj: deps $(DJINNI_OUT_DIR) libhellodjinni.gyp \ $(DEPS_DJINNI_DIR)/support-lib/support_lib.gyp @echo "\033[1;35;47mGenerate libhellodjinni.xcodeproj...\033[0m" @$(GYP_DIR)/gyp --depth=. -f xcode -DOS=ios \ --generator-output $(IOS_OUT) \ -DDJINNI_DIR=$(DEPS_DJINNI_DIR) \ -I$(DEPS_DJINNI_DIR)/common.gypi \ libhellodjinni.gyp.PHONY: ios_proios_pro: $(IOS_OUT)/libhellodjinni.xcodeproj @echo "\033[1;35;47mBuild ios project...\033[0m" xcodebuild -workspace ios/HelloDjinni.xcworkspace \ -scheme HelloDjinni -configuration 'Debug' -sdk iphonesimulator.PHONY: ios_pro_cleanios_pro_clean: @echo "\033[1;35;47mClean ios project...\033[0m" @-xcodebuild -workspace ios/HelloDjinni.xcworkspace \ -scheme HelloDjinni -configuration 'Debug' -sdk iphonesimulator clean../GypAndroid.mk: deps $(DJINNI_OUT_DIR) libhellodjinni.gyp \ $(DEPS_DJINNI_DIR)/support-lib/support_lib.gyp @echo "\033[1;35;47mGenerate GypAndroid.mk...\033[0m" @make gyp_android @cd .. &amp;&amp; ANDROID_BUILD_TOP=$(NDK_DIR) \ $(GYP_DIR)/gyp --depth=. -f android -DOS=android \ -DDJINNI_DIR=$(DEPS_DJINNI_DIR) \ -Iproject/$(DEPS_DJINNI_DIR)/common.gypi \ project/libhellodjinni.gyp \ --root-target=libhellodjinni_jni @make gyp_master.PHONY: android_proandroid_pro: ../GypAndroid.mk @echo "\033[1;35;47mBuild android project (HelloDjinni)...\033[0m" cd android/HelloDjinni/ &amp;&amp; ./gradlew app:assembleDebug @echo "\033[32mApks produced at:\033[0m" @python $(DEPS_DJINNI_DIR)/example/glob.py \ android/HelloDjinni/app/build/outputs/apk/ '*.apk'.PHONY: android_pro_cleanandroid_pro_clean: ../GypAndroid.mk @echo "\033[1;35;47mClean android project (HelloDjinni)...\033[0m" @ndk-build -C android/HelloDjinni/app-core clean @-cd android/HelloDjinni/ &amp;&amp; ./gradlew clean.PHONY: android_pro2android_pro2: deps djinni libhellodjinni.gyp \ $(DEPS_DJINNI_DIR)/support-lib/support_lib.gyp @echo "\033[1;35;47mBuild android project (HelloDjinni2)...\033[0m" cd android/HelloDjinni2/ &amp;&amp; ./gradlew app:assembleDebug @echo "\033[32mApks produced at:\033[0m" @python $(DEPS_DJINNI_DIR)/example/glob.py \ android/HelloDjinni2/app/build/outputs/apk/ '*.apk'.PHONY: android_pro2_cleanandroid_pro2_clean: @echo "\033[1;35;47mClean android project (HelloDjinni2)...\033[0m" @-cd android/HelloDjinni2/ &amp;&amp; ./gradlew clean.PHONY: gyp_statusgyp_status: @cd $(GYP_DIR) &amp;&amp; git status.PHONY: gyp_mastergyp_master: @echo "\033[1;35;47mCheckout gyp to master...\033[0m" @cd $(GYP_DIR) &amp;&amp; git checkout master.PHONY: gyp_androidgyp_android: @echo "\033[1;35;47mCheckout gyp to android generator...\033[0m" @cd $(GYP_DIR) &amp;&amp; git checkout -q 0bb67471bca068996e15b56738fa4824dfa19de0.PHONY: test_varstest_vars: @echo "\033[1;35;47mPrint variables...\033[0m" @echo GYP_DIR=$(GYP_DIR) @echo NDK_DIR=$(NDK_DIR) @echo OUT_DIR=$(OUT_DIR) @echo IOS_OUT=$(IOS_OUT) @echo DEPS_DIR=$(DEPS_DIR) @echo DEPS_DJINNI_DIR=$(DEPS_DJINNI_DIR) 其也包括了 Android 工程的配置。 注：额外依赖了两个辅助脚本，说明如下：read_properties.sh，读取local.properties内配置的路径。prepare_deps.sh，准备依赖的文件到指定目录。 然后，运行生成 XCode 的 libhellodjinni 工程。 12$ cd project/$ make ios_pro 其生成在project/build/ios目录。 XCode 直接打开libhellodjinni.xcodeproj，即可选择目标进行编译。 但可能此时 libhellodjinni_jni 与 djinni_jni (support_lib) 目标，不能够找到jni.h。由于 ios 上不需要 jni 绑定，后续也不需依赖，没多大影响。 也让其可通过编译的话，只需要选择目标，在”Build Settings &gt; Header Search Paths”内，添加 Java VM include 就好。 运行如下命令，获得当前的 Java 头文件路径： 1$ ls -l `which java` | sed 's/^.*-&gt; *\(.*Current\).*$/\1\/Headers/;q' 结果，如：”/System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers”。 或者，这里找：”/Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/include/“。 添加接口 Libraries 依赖现在，给 iOS 工程上添加上接口 Libraries 的依赖。 首先，打开先前的工作区project/ios/HelloDjinni.xcworkspace。于左侧项目导航的灰色区域，”Ctrl+Click”或右击打开菜单。选择”Add Files to “HelloDjinni””，添加生成好的libhellodjinni.xcodeproj和support_lib.xcodeproj两个库工程。 之后，项目导航选中”HelloDjinni”工程，并选择”HelloDjinni”目标。在”Build Phases”标签页的”Link Binaries With Libraries”选项下，新增 libhellodjinni_objc.a 与 libdjinni_objc.a 的依赖，如下： {% asset_img ios_pro_lib_link.png %} 在”Build Settings”标签页，找到”Header Search Paths”，添加头文件搜索路径： 12$(SRCROOT)/../../deps/djinni/support-lib/objc$(SRCROOT)/../../../generated-src/objc 为了兼容 Objective-C++ 桥接代码，需要将HelloWorld/Supporting Files/main.m重命名为main.mm。 最终，工作区会类似于下面这样： {% asset_img ios_pro_overview.png %} 完成 UI 并运行于ViewController.m内编写代码，创建 UI 并调用接口代码。 project/ios/HelloDjinni/HelloDjinni/ViewController.mViewController.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import "ViewController.h"#import "HDHelloDjinni.h"@interface ViewController ()@end@implementation ViewController &#123; HDHelloDjinni *_helloDjinniInterface; UIButton *_button; UITextView *_textView;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // instantiate our library interface _helloDjinniInterface = [HDHelloDjinni create]; // create a button programatically for the demo _button = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [_button addTarget:self action:@selector(buttonWasPressed:) forControlEvents:UIControlEventTouchUpInside]; [_button setTitle:@"Get Hello Djinni!" forState:UIControlStateNormal]; _button.frame = CGRectMake(20.0, 20.0, 280.0, 40.0); [self.view addSubview:_button]; // create a text view programatically _textView = [[UITextView alloc] init]; // x, y, width, height _textView.frame = CGRectMake(20.0, 80.0, 280.0, 380.0); [self.view addSubview:_textView];&#125;- (void)buttonWasPressed:(UIButton *)sender &#123; NSString *response = [_helloDjinniInterface getHelloDjinni]; _textView.text = [NSString stringWithFormat:@"%@\n%@", response, _textView.text];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end “Product &gt; Run”运行项目。 UI 上”Get Hello Djinni!”的按钮，每点击下就会添加条从 C++ 返回的信息。 Android 工程Android 工程介绍了两种方式，来整合 NDK Library ： 一是，使用 GYP 生成的 Android Makefile ， Gradle 配置 ndk-build 进行编译。 二是，使用 Experimental Plugin ，直接配置成支持 NDK 的工程。 使用 GypMakefileGYP 生成 Android Makefile ，使用之前写好的project/Makefile： 12$ cd project/$ make android_pro GypAndroid.mk会生成到父级hellodjinni目录。 如果还没准备好 Studio 工程，不会继续生成 APK ，会报“找不到android/HelloDjinni/”。 现在，打开 Android Studio，选择”Start a new Android Studio Project”。 “New”页，”Project Location”存到project/android/HelloDjinni，如下： {% asset_img android_pro_new.png %} 之后，”Target”页选”Phone and Tablet”，”Add”页选”Empty Activity”，最终完成新建。 于”File &gt; Project Structure &gt; SDK Location &gt; Android NDK Location”，设置 NDK 路径： {% asset_img android_pro_sdk.png %} 接下来，独立建一个 app-core Library 模块来引用 C++ 代码。”File &gt; New Module”，选”Android Library”： {% asset_img android_pro_new_lib.png %} 然后，修改此 app-core 的build.gradle，添加引用及 NDK 编译。变更如下： project/android/HelloDjinni/app-core/build.gradlebuild.gradle12345678910111213141516171819202122232425262728293031323334353637apply plugin: 'com.android.library'android &#123; ... sourceSets &#123; main &#123; java.srcDirs += ['../../../../generated-src/java'] jni.srcDirs = [] jniLibs.srcDirs = ['libs'] &#125; &#125;&#125;dependencies &#123; ... //compile 'com.android.support:appcompat-v7:23.3.0'&#125;task ndkBuild(type: Exec) &#123; def ndkDir = plugins.getPlugin('com.android.library').sdkHandler.ndkFolder if (ndkDir == null) &#123; def gradle_project_root = project.rootProject.rootDir throw new GradleException("NDK is not configured. Make sure there is a local.properties " + "file with an ndk.dir entry in the directory $&#123;gradle_project_root&#125;.") &#125; def ndkBuildExecutable = new File(ndkDir, 'ndk-build') if (!ndkBuildExecutable.exists()) &#123; throw new GradleException("Could not find ndk-build. The configured NDK directory $&#123;ndkDir&#125; may not be correct.") &#125; environment("NDK_PROJECT_PATH", projectDir) environment("GYP_CONFIGURATION", "Release") commandLine ndkBuildExecutable&#125;tasks.withType(JavaCompile) &#123; compileTask -&gt; compileTask.dependsOn ndkBuild&#125; 项目导航栏切到 Project 视图，在 app-core 下新建jni目录，创建 NDK 的工程文件。 project/android/HelloDjinni/app-core/jni/Android.mkAndroid.mk123# always force this build to re-run its dependenciesFORCE_GYP := $(shell make -C ../../../../ GypAndroid.mk)include ../../../../GypAndroid.mk project/android/HelloDjinni/app-core/jni/Application.mkApplication.mk1234567891011121314151617# Android makefile for libhellodjinni shared lib# Application.mk: http://developer.android.com/ndk/guides/application_mk.html# APP_ABI := all# skipping mips / mips64APP_ABI := armeabi armeabi-v7a arm64-v8a x86 x86_64APP_OPTIM := releaseAPP_PLATFORM := android-14# GCC 4.9 Toolchain - requires NDK r10NDK_TOOLCHAIN_VERSION = 4.9# GNU libc++ is the only Android STL which supports C++11 featuresAPP_CFLAGS += -WallAPP_CPPFLAGS += -std=c++11 -frtti -fexceptionsAPP_STL := gnustl_staticAPP_BUILD_SCRIPT := jni/Android.mkAPP_MODULES := libhellodjinni_jni 这样，独立的 app-core Library 就👌了。 回到 app ，修改其build.gradle，以依赖 app-core 。变更如下： project/android/HelloDjinni/app/build.gradlebuild.gradle1234dependencies &#123; ... compile project(':app-core')&#125; 新建MyApplication.java，作为自定义 Application。并设置到AndroidManifest.xml内”application”的”name”字段。 project/android/HelloDjinni/app/src/.../MyApplication.javaMyApplication.java12345678910111213141516171819package cc.eevee.hellodjinni;import android.app.Application;public class MyApplication extends Application &#123; static &#123; try &#123; System.loadLibrary("hellodjinni_jni"); &#125; catch (UnsatisfiedLinkError e) &#123; System.err.println("Native code library failed to load.\n" + e); &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125;&#125; 最终，项目导航 Android 和 Project 视图类似下面这样： {% asset_img android_pro_nav.png %} 接着，修改 app UI，MainActivity.java及其布局activity_main.xml： project/android/HelloDjinni/app/src/.../MainActivity.javaMainActivity.java12345678910111213141516171819202122232425262728package cc.eevee.hellodjinni;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.ScrollView;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView mTextView; private ScrollView mScrollView; private HelloDjinni mHelloDjinniInterface = HelloDjinni.create(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.textView); mScrollView = (ScrollView) findViewById(R.id.scrollView); &#125; public void onButtonClick(View view) &#123; mTextView.append(mHelloDjinniInterface.getHelloDjinni() + "\n"); mScrollView.fullScroll(ScrollView.FOCUS_DOWN); &#125;&#125; project/android/HelloDjinni/app/src/.../activity_main.xmlactivity_main.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="cc.eevee.hellodjinni.MainActivity"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Get Hello Djinni!" android:gravity="center" android:onClick="onButtonClick"/&gt; &lt;ScrollView android:id="@+id/scrollView" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/textView" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; “Run &gt; Run ‘app’”运行项目。 UI 上”Get Hello Djinni!”的按钮，每点击下就会添加条从 C++ 返回的信息。 {% img /2016/05/06/using-djinni/android_pro_result.png 300 %} 使用新试验性插件Android Studio 1.3 版本开始支持 NDK，需要使用 Experimental Plugin 。这里为当前最新的 0.7.0 版本。 同样，打开 Android Studio，选择”Start a new Android Studio Project”，新建一个”HelloDjinni2”工程。 {% asset_img android_pro2_new.png %} 之后，”Target”页选”Phone and Tablet”，”Add”页选”Empty Activity”，最终完成新建。 于”File &gt; Project Structure &gt; SDK Location &gt; Android NDK Location”，设置 NDK 路径。 接下来，修改成 Experimental Plugin 。先是工程配置： project/android/HelloDjinni2/build.gradlebuild.gradle1234567891011121314151617181920212223// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle-experimental:0.7.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 接着是 app 模块配置： project/android/HelloDjinni2/app/build.gradlebuild.gradle1234567891011121314151617181920212223242526272829apply plugin: 'com.android.model.application'model &#123; android &#123; compileSdkVersion = 23 buildToolsVersion = '23.0.3' defaultConfig &#123; applicationId = 'cc.eevee.hellodjinni2' minSdkVersion.apiLevel = 14 targetSdkVersion.apiLevel = 23 versionCode = 1 versionName = '1.0' &#125; buildTypes &#123; release &#123; minifyEnabled = false proguardFiles.add(file('proguard-rules.pro')) &#125; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.3.0' //compile project(':app-core')&#125; 这样， Experimental Plugin 就修改完成了。 接下来，仍旧独立建一个 app-core Library 模块来引用 C++ 代码。”File &gt; New Module”，选”Android Library”： {% asset_img android_pro2_new_lib.png %} 然后，修改此 app-core 的build.gradle，支持 Experimental Plugin 并配置 NDK 。如下： project/android/HelloDjinni2/app-core/build.gradlebuild.gradle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364apply plugin: 'com.android.model.library'model &#123; android &#123; compileSdkVersion = 23 buildToolsVersion = '23.0.3' defaultConfig &#123; minSdkVersion.apiLevel = 14 targetSdkVersion.apiLevel = 23 &#125; ndk &#123; moduleName = 'hellodjinni' platformVersion = 14 toolchain = 'gcc' toolchainVersion = '4.9' stl = 'gnustl_shared' CFlags.addAll(['-Wall', '-Werror']) cppFlags.addAll(['-std=c++11', '-fexceptions', '-frtti']) cppFlags.addAll([ "-I$&#123;file('../../../deps/djinni/support-lib')&#125;".toString(), "-I$&#123;file('../../../deps/djinni/support-lib/jni')&#125;".toString(), "-I$&#123;file('../../../../generated-src/cpp')&#125;".toString(), "-I$&#123;file('../../../../generated-src/jni')&#125;".toString(), ]) ldLibs.addAll(['log']) abiFilters.addAll(['armeabi', 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64']) &#125; sources &#123; //noinspection GroovyAssignabilityCheck main &#123; jni &#123; source &#123; srcDirs += [ '../../../deps/djinni/support-lib/jni', '../../../../generated-src/cpp', '../../../../generated-src/jni', '../../../../src/cpp', ] &#125; &#125; java &#123; source &#123; srcDirs += [ '../../../../generated-src/java', ] &#125; &#125; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled = false proguardFiles.add(file('proguard-rules.pro')) &#125; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' //compile 'com.android.support:appcompat-v7:23.3.0'&#125; 这样之后，可以在 app-core 下看得jni目录，包括了所有 C++ 代码。 回到 app ，修改其build.gradle，以依赖 app-core 。变更如下： project/android/HelloDjinni2/app/build.gradlebuild.gradle1234dependencies &#123; ... compile project(':app-core')&#125; 新建MyApplication.java，作为自定义 Application。并设置到AndroidManifest.xml内”application”的”name”字段。 project/android/HelloDjinni2/app/src/.../MyApplication.javaMyApplication.java1234567891011121314151617181920package cc.eevee.hellodjinni2;import android.app.Application;public class MyApplication extends Application &#123; static &#123; try &#123; System.loadLibrary("gnustl_shared"); System.loadLibrary("hellodjinni"); &#125; catch (UnsatisfiedLinkError e) &#123; System.err.println("Native code library failed to load.\n" + e); &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125;&#125; 最终，项目导航 Android 和 Project 视图类似下面这样： {% asset_img android_pro2_nav.png %} 接着，修改 app UI，MainActivity.java及其布局activity_main.xml： project/android/HelloDjinni2/app/src/.../MainActivity.javaMainActivity.java123456789101112131415161718192021222324252627282930package cc.eevee.hellodjinni2;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.ScrollView;import android.widget.TextView;import cc.eevee.hellodjinni.HelloDjinni;public class MainActivity extends AppCompatActivity &#123; private TextView mTextView; private ScrollView mScrollView; private HelloDjinni mHelloDjinniInterface = HelloDjinni.create(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView) findViewById(R.id.textView); mScrollView = (ScrollView) findViewById(R.id.scrollView); &#125; public void onButtonClick(View view) &#123; mTextView.append(mHelloDjinniInterface.getHelloDjinni() + "\n"); mScrollView.fullScroll(ScrollView.FOCUS_DOWN); &#125;&#125; project/android/HelloDjinni2/app/src/.../activity_main.xmlactivity_main.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="cc.eevee.hellodjinni2.MainActivity"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Get Hello Djinni!" android:gravity="center" android:onClick="onButtonClick"/&gt; &lt;ScrollView android:id="@+id/scrollView" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/textView" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; “Run &gt; Run ‘app’”运行项目。 UI 上”Get Hello Djinni!”的按钮，每点击下就会添加条从 C++ 返回的信息。 {% img /2016/05/06/using-djinni/android_pro2_result.png 300 %} NDK 参考 NDK Guides Android NDK Preview Experimental Plugin User Guide Error: NDK integration is deprecated in the current plugin 结语：开始使用 Djinni 吧附：源码Hello Djinni 的源码，这样得到： 12$ git clone https://github.com/joinAero/XCalculator.git$ cd sample/hellodjinni/ 修改local.properties设好环境。执行make编译，make clean清理。 文件结构： 1234567891011121314hellodjinni/├─project/│ ├─android/│ │ ├─HelloDjinni/ # Android Project with GYP &amp; ndk-build│ │ └─HelloDjinni2/ # Android Project with Experimental Plugin│ ├─cpp/│ │ └─HelloDjinni/ # Cpp Test Project│ └─ios/│ ├─HelloDjinni/│ └─HelloDjinni.xcworkspace/ # iOS Project Workspace├─src/│ └─cpp/ # Cpp Interface Impls├─tools/ # Helper Scripts└─local.properties # Local Properties 附：运行环境1234567891011121314151617181920212223# OSProductName: Mac OS X ProductVersion: 10.11.4 BuildVersion: 15E65# XCodeXcode 7.3.1 Build version 7D1014# XCode 命令行工具# xcode-select --installxcode-select version 2343.# Javajava version "1.8.0_25"Java(TM) SE Runtime Environment (build 1.8.0_25-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)# Android Studio# Android Studio &gt; About Android Studio# Android Studio &gt; Appearance &amp; Behavior &gt; System Settings &gt; UpdatesAndroid Studio 2.1Build #AI-143.2790544# Android NDKGNU Make 3.81 Copyright (C) 2006 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. This program built for i386-apple-darwin11.3.0 如果未添加过 Android 环境变量，请于 ~/.bash_profile 文件内设置： 12345export ANDROID_HOME=$HOME/Develop/android-sdkexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-toolsexport ANDROID_NDK_HOME=$HOME/Develop/android-ndkexport PATH=$PATH:$ANDROID_NDK_HOME 终端运行如下命令可立即生效： 1$ source ~/.bash_profile 验证 SDK 与 NDK 命令行工具可用： 123$ which android$ which ndk-build 验证 XCode 命令行工具可用： 123$ which xcrun$ which xcodebuild 附：参考内容 Your First Cross-Platform Djinni App iOS和Android的C++跨平台开发 | Dropbox]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Djinni</tag>
        <tag>Cpp</tag>
        <tag>Android</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>